// Generated by CoffeeScript 1.10.0
(function() {
  var Board, Promise, assert, events, rfcontrol, settled,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Promise = require('bluebird');

  assert = require('assert');

  events = require('events');

  rfcontrol = require('rfcontroljs');

  settled = function(promise) {
    return Promise.settle([promise]);
  };

  Board = (function(superClass) {
    extend(Board, superClass);

    Board.HIGH = 1;

    Board.LOW = 0;

    Board.INPUT = 0;

    Board.OUTPUT = 1;

    Board.INPUT_PULLUP = 2;

    Board.prototype._awaitingAck = [];

    Board.prototype._opened = false;

    Board.prototype.ready = false;

    function Board(driver, driverOptions) {
      this._waitForAcknowledge = bind(this._waitForAcknowledge, this);
      this._onAcknowledge = bind(this._onAcknowledge, this);
      var GpioDriver, SerialPortDriver, TcpDriver;
      assert(driver === "serialport" || driver === "gpio" || driver === "tcp");
      switch (driver) {
        case "serialport":
          SerialPortDriver = require('./driver/serialport');
          this.driver = new SerialPortDriver(driverOptions);
          break;
        case "gpio":
          GpioDriver = require('./driver/gpio');
          this.driver = new GpioDriver(driverOptions);
          break;
        case "tcp":
          TcpDriver = require('./driver/tcp');
          this.driver = new TcpDriver(driverOptions);
      }
      this._lastAction = Promise.resolve();
      this.driver.on('ready', (function(_this) {
        return function(boardinfo) {
          _this._lastDataTime = new Date().getTime();
          _this.ready = true;
          return _this.emit('ready', boardinfo);
        };
      })(this));
      this.driver.on('error', (function(_this) {
        return function(error) {
          return _this.emit('error', error);
        };
      })(this));
      this.driver.on('reconnect', (function(_this) {
        return function(error) {
          return _this.emit('reconnect', error);
        };
      })(this));
      this.driver.on('close', (function(_this) {
        return function() {
          _this.ready = false;
          return _this.emit('close');
        };
      })(this));
      this.driver.on("data", (function(_this) {
        return function(data) {
          return _this.emit("data", data);
        };
      })(this));
      this.driver.on("line", (function(_this) {
        return function(line) {
          _this.emit("line", line);
          return _this._onLine(line);
        };
      })(this));
      this.on('ready', (function(_this) {
        return function() {
          return _this.setupWatchdog();
        };
      })(this));
    }

    Board.prototype.connect = function(timeout, retries) {
      this.timeout = timeout != null ? timeout : 5 * 60 * 1000;
      this.retries = retries != null ? retries : 3;
      return this.pendingConnect = this.driver.connect(this.timeout, this.retries);
    };

    Board.prototype.disconnect = function() {
      this.stopWatchdog();
      return this.driver.disconnect();
    };

    Board.prototype.setupWatchdog = function() {
      this.stopWatchdog();
      return this._watchdogTimeout = setTimeout(((function(_this) {
        return function() {
          var now;
          now = new Date().getTime();
          if (now - _this._lastDataTime < _this.timeout) {
            _this.setupWatchdog();
            return;
          }
          return _this.driver.write("PING\n").then(function() {
            return _this.setupWatchdog();
          }).timeout(20 * 1000)["catch"](function(err) {
            _this.emit('reconnect', err);
            _this.connect(_this.timeout, _this.retries)["catch"](function(error) {
              _this.emit('reconnect', err);
            });
          });
        };
      })(this)), 20 * 1000);
    };

    Board.prototype.stopWatchdog = function() {
      return clearTimeout(this._watchdogTimeout);
    };

    Board.prototype._onLine = function(line) {
      var args, cmd;
      this._lastDataTime = new Date().getTime();
      args = line.split(" ");
      assert(args.length >= 1);
      cmd = args[0];
      args.splice(0, 1);
      switch (cmd) {
        case 'ACK':
        case 'ERR':
          return this._handleAcknowledge(cmd, args);
        case 'RF':
          return this._handleRFControl(cmd, args);
        case 'KP':
          return this._handleKeypad(cmd, args);
        case 'PING':
          break;
        default:
          return console.log("unknown message received: " + line);
      }
    };

    Board.prototype.whenReady = function() {
      if (this.pendingConnect == null) {
        return Promise.reject(new Error("First call connect!"));
      }
      return this.pendingConnect;
    };

    Board.prototype.writeAndWait = function(data) {
      return this._lastAction = settled(this._lastAction).then((function(_this) {
        return function() {
          return Promise.all([_this.driver.write(data), _this._waitForAcknowledge()]).then(function(arg) {
            var _, result;
            _ = arg[0], result = arg[1];
            return result;
          });
        };
      })(this));
    };

    Board.prototype.digitalWrite = function(pin, value) {
      assert(typeof pin === "number");
      assert(value === 0 || value === 1);
      return this.writeAndWait("DW " + pin + " " + value + "\n");
    };

    Board.prototype.analogWrite = function(pin, value) {
      assert(typeof pin === "number");
      assert(typeof value === "number");
      return this.writeAndWait("AW " + pin + " " + value + "\n");
    };

    Board.prototype.digitalRead = function(pin) {
      assert(typeof pin === "number");
      return this.writeAndWait("DR " + pin + "\n").then(function(result) {
        return parseInt(result, 10);
      });
    };

    Board.prototype.analogRead = function(pin) {
      assert(typeof pin === "number");
      return this.writeAndWait("AR " + pin + "\n").then(function(result) {
        return parseInt(result, 10);
      });
    };

    Board.prototype.pinMode = function(pin, mode) {
      assert(typeof pin === "number");
      assert(mode === 0 || mode === 1 || mode === 2);
      return this.writeAndWait("PM " + pin + " " + mode + "\n");
    };

    Board.prototype.readDHT = function(type, pin) {
      assert(type === 11 || type === 21 || type === 22 || type === 33 || type === 44 || type === 55);
      assert(typeof pin === "number", "pin should be a number");
      return this.writeAndWait("DHT " + type + " " + pin + "\n").then(function(args) {
        return {
          temperature: parseFloat(args[0]),
          humidity: parseFloat(args[1])
        };
      });
    };

    Board.prototype.readDstSensors = function(pin) {
      var promise, reading;
      reading = this.writeAndWait("DST " + pin + " sensors\n");
      promise = reading.then(function(args) {
        args.shift();
        return {
          sensors: args
        };
      });
      return promise;
    };

    Board.prototype.readDstSensor = function(pin, address) {
      var promise, reading;
      reading = this.writeAndWait("DST " + pin + " " + address + "\n");
      promise = reading.then(function(args) {
        return {
          temperature: parseFloat(args)
        };
      });
      return promise;
    };

    Board.prototype.readDstAll = function(pin) {
      var promise, reading;
      reading = this.writeAndWait("DST " + pin + " all\n");
      promise = reading.then(function(args) {
        return {
          temperature: parseFloat(args[0])
        };
      });
      return promise;
    };

    Board.prototype.rfControlStartReceiving = function(pin) {
      assert(typeof pin === "number", "pin should be a number");
      return this.writeAndWait("RF receive " + pin + "\n");
    };

    Board.prototype.rfControlSendMessage = function(pin, repeats, protocolName, message) {
      var result;
      result = rfcontrol.encodeMessage(protocolName, message);
      return this.rfControlSendPulses(pin, repeats, result.pulseLengths, result.pulses);
    };

    Board.prototype.rfControlSendPulses = function(pin, repeats, pulseLengths, pulses) {
      var i, j, len, pl, pulseLengthsArgs;
      assert(typeof pin === "number", "pin should be a number");
      assert(Array.isArray(pulseLengths), "pulseLengths should be an array");
      assert(pulseLengths.length <= 8, "pulseLengths.length should be <= 8");
      assert(typeof pulses === "string", "pulses should be a string");
      pulseLengthsArgs = "";
      i = 0;
      for (j = 0, len = pulseLengths.length; j < len; j++) {
        pl = pulseLengths[j];
        pulseLengthsArgs += " " + pl;
        i++;
      }
      while (i < 8) {
        pulseLengthsArgs += " 0";
        i++;
      }
      return this.writeAndWait("RF send " + pin + " " + repeats + " " + pulseLengthsArgs + " " + pulses + "\n");
    };

    Board.prototype._onAcknowledge = function() {
      return new Promise((function(_this) {
        return function(resolve) {
          return _this._awaitingAck.push(resolve);
        };
      })(this));
    };

    Board.prototype._waitForAcknowledge = function() {
      return this._onAcknowledge().then((function(_this) {
        return function(arg) {
          var args, cmd;
          cmd = arg.cmd, args = arg.args;
          switch (cmd) {
            case 'ERR':
              throw new Error(args[0]);
              break;
            case 'ACK':
              switch (args.length) {
                case 0:
                  break;
                case 1:
                  return args[0];
                default:
                  return args;
              }
              break;
            default:
              return assert(false);
          }
        };
      })(this));
    };

    Board.prototype._handleAcknowledge = function(cmd, args) {
      var resolver;
      assert(this._awaitingAck.length > 0);
      resolver = this._awaitingAck[0];
      resolver({
        cmd: cmd,
        args: args
      });
      this._awaitingAck.splice(0, 1);
    };

    Board.prototype._handleRFControl = function(cmd, args) {
      var a, info, j, len, ref, strSeq;
      if (!(args.length === 10 && args[0] === 'receive')) {
        console.log("Unknown RF response \"" + (args.join(" ")) + "\"");
        return;
      }
      strSeq = args[1];
      ref = args.slice(2, 10);
      for (j = 0, len = ref.length; j < len; j++) {
        a = ref[j];
        strSeq += " " + a;
      }
      info = rfcontrol.prepareCompressedPulses(strSeq);
      this._emitReceive(info);
    };

    Board.prototype.provessExternalReceive = function(pulseLengths, pulses) {
      var info;
      info = rfcontrol.sortCompressedPulses(pulseLengths, pulses);
      this._emitReceive(info);
    };

    Board.prototype._emitReceive = function(info) {
      var j, len, r, results;
      this.emit('rfReceive', info);
      results = rfcontrol.decodePulses(info.pulseLengths, info.pulses);
      for (j = 0, len = results.length; j < len; j++) {
        r = results[j];
        this.emit('rf', r);
      }
    };

    Board.prototype._handleKeypad = function(cmd, args) {
      var key;
      assert(args.length === 1);
      key = args[0];
      this.emit('keypad', {
        key: key
      });
    };

    Board.getRfProtocol = function(protocolName) {
      return rfcontrol.getProtocol(protocolName);
    };

    Board.getAllRfProtocols = function() {
      return rfcontrol.getAllProtocols();
    };

    return Board;

  })(events.EventEmitter);

  module.exports = Board;

}).call(this);
